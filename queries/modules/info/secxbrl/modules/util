jsoniq version "1.0";

module namespace util = "http://secxbrl.info/modules/util";


import module namespace session = "http://apps.28.io/session";
import module namespace response = "http://www.28msec.com/modules/http-response";
import module namespace request = "http://www.28msec.com/modules/http-request";

import module namespace facts = "http://xbrl.io/modules/bizql/facts";
import module namespace entities = "http://xbrl.io/modules/bizql/entities";
import module namespace archives = "http://xbrl.io/modules/bizql/archives";
import module namespace components = "http://xbrl.io/modules/bizql/components";
import module namespace components2 = "http://xbrl.io/modules/bizql/components2";

import module namespace companies = "http://xbrl.io/modules/bizql/profiles/sec/companies";
import module namespace sec-fiscal = "http://xbrl.io/modules/bizql/profiles/sec/fiscal/core";
import module namespace sec-networks = "http://xbrl.io/modules/bizql/profiles/sec/networks";

declare %an:sequential function util:check-and-return-results(
    $entities as object*,
    $results as item*,
    $format as string
) as item*
{
    switch(session:check-access($entities, "data_sec"))
    case $session:ACCESS-ALLOWED return
        $results
    case $session:ACCESS-DENIED return {
          response:status-code(403);
          session:error("accessing filings of an entity that is not in the DOW30", $format)
       }
    case $session:ACCESS-AUTH-REQUIRED return {
          response:status-code(401);
          session:error("authentication required or session expired", $format)
       }
    default return error()
};

declare function util:entities-from-parameters(
    $parameters as object,
    $options as object?) as object*
{
    if ($parameters.Tags[] = "ALL")
    then companies:companies()
    else companies:companies-for({
            ciks : $parameters.CIKs,
            tags : $parameters.Tags,
            tickers : $parameters.Tickers,
            sic : $parameters.SICs
    }),
    if($options.ResolveArchives)
    then entities:entities(archives:entities($parameters.AIDs[]))
    else ()
};

declare function util:filings-from-parameters(
    $parameters as object,
    $options as object?) as object*
{
    let $fy := $parameters.FiscalYears[]
    let $fp := $parameters.FiscalPeriods[]
    let $fiscal-years as integer* :=
        switch(true)
        case exists(index-of($fy, "ALL")) return $sec-fiscal:ALL_FISCAL_YEARS
        default return $fy[not deep-equal($$, "LATEST")]
    let $fiscal-periods as string* :=
        switch(true)
        case $fp = "ALL" return $sec-fiscal:ALL_FISCAL_PERIODS
        default return $fp
    let $entities := util:entities-from-parameters($parameters, { ResolveArchives: false })
    return
        if(deep-equal($fy, "LATEST"))
        then
            for $entity in $entities
            return
            util:latest-filings($entity, $fp)
        else
            sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entities, $fiscal-periods, $fiscal-years),
    archives:archives($parameters.AIDs[])
};

declare function util:components-from-parameters(
    $parameters as object,
    $options as object?) as object*
{
    let $archives := util:filings-from-parameters($parameters, { ResolveArchives: true })
    return(
        components:components($parameters.CIDs[])[exists($parameters.CIDs)],
        if (exists(($parameters.ReportElements[], $parameters.Concepts[], $parameters.Disclosures[], $parameters.Roles[], $parameters.Search[])))
        then (
                components2:components-for-archives-and-concepts($archives, $parameters.Concepts[]),
                sec-networks:networks-for-filings-and-disclosures($archives, $parameters.Disclosures[]),
                components2:components-for-archives-and-roles($archives, $parameters.Roles[]),
                sec-networks:networks-for-filings-and-reportElements($archives, $parameters.ReportElements[]),
                sec-networks:networks-for-filings-and-label($archives, $parameters.Search[])
            )
        else components:components-for-archives($archives)
    )
};

declare function util:filings(
    $entities as object*,
    $fp as string*,
    $fy as string*) as object*
{
    for $entity in $entities
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    let $filings := sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-periods, $fiscal-years)
    return
        if(deep-equal($fy, "LATEST"))
        then $latest-filings
        else $filings
};

declare function util:latest-filings(
    $entities as object*,
    $fiscal-periods as string*) as object*
{
    for $entity in $entities
    for $fiscal-period in $fiscal-periods 
    let $latest-fiscal-year :=
        if ($fiscal-period eq "FY")
        then sec-fiscal:latest-reported-fiscal-period($entity, "10-K").year 
        else sec-fiscal:latest-reported-fiscal-period($entity, "10-Q").year
    return sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-period, $latest-fiscal-year cast as integer?)
};

declare function util:filter-override-from-parameters(
    $parameters as object,
    $options as object?) as object?
{
    let $entities := util:entities-from-parameters($parameters, $options)
    let $fy := $parameters.FiscalYears[]
    let $fp := $parameters.FiscalPeriods[]
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case exists(index-of($fy, "ALL")) return ()
        default return distinct-values(
            $fy[not deep-equal($$, "LATEST")] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    return
    switch(true)
    case size($parameters.AIDs) gt 0 return {
        "sec:Archive" : {
            Type: "string",
            Domain : $parameters.AIDs
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case deep-equal($fy, "LATEST")
    return {
        "sec:Archive" : {
            Type: "string",
            Domain : [archives:aid($latest-filings)]
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case exists(($entities, $fiscal-years, $fiscal-periods))
    return {
        "xbrl:Entity" : {|
            {
                Type: "string",
                Domain: [ $entities._id ]
            }[exists($entities)]
        |},
        "sec:FiscalYear" : {|
            {
                Type: "integer",
                Domain: [ $fiscal-years ]
            }[exists($fiscal-years)]
        |},
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |},
        "sec:Archive" : {}
    }
    default return ()
};

declare function util:process-parameters($parameters as object) as object
{
    let $format as string? :=
        lower-case(($parameters.Format, substring-after(request:path(), ".jq."))[1])
    let $ciks as string* :=
        companies:eid($parameters.CIKs[])
    let $tags as string* :=
        distinct-values($parameters.Tags[] ! upper-case($$))
    let $fiscalYears as atomic* :=
        distinct-values(
        for $y in $parameters.FiscalYears[]
        return
            if ($y eq "LATEST" or $y eq "ALL")
            then $y
            else if ($y castable as integer)
            then integer($y)
            else ()
        )
    let $fiscalPeriods as atomic* :=
            if (($parameters.FiscalPeriods[] ! lower-case($$)) = "all")
            then $sec-fiscal:ALL_FISCAL_PERIODS
            else $parameters.FiscalPeriods[]
    let $aids as string* := archives:aid($parameters.AIDs[])
    let $validate as boolean := $parameters.Validate = "true"
    let $eliminate as boolean := $parameters.Eliminate = "true"

    return facts:merge-objects({|
        {
            CIKs: [ $ciks ],
            Tags: [ $tags ],
            FiscalYears: [ $fiscalYears ],
            FiscalPeriods: [ $fiscalPeriods ],
            AIDs: [ $aids ],
            Validate: $validate,
            Eliminate: $eliminate
        },
        { Format: $format}[exists($format)]
    |}, $parameters, true)
};

declare function util:move-unit-out-of-aspects(
    $facts as object*) as object*
{
    for $fact in $facts
    return {|
        {
            "Aspects" : {|
                trim($fact.Aspects, ("xbrl:Unit"))
            |}
        },
        trim($fact, ("Aspects")),
        { Unit: $fact.Aspects."xbrl:Unit" }[exists($fact.Aspects."xbrl:Unit")]
    |}
};

declare %an:sequential function util:serialize(
    $result as json-item,
    $comment as object,
    $serializers as object,
    $format as string?) as item*
{
    switch ($format)
    case "xml" return {
        response:serialization-parameters({"omit-xml-declaration" : false, indent : true });
        session:comment("xml", $comment),
        $serializers.to-xml($result)
    }
    case "text" case "csv" return {
        response:content-type("text/csv");
        response:header("Content-Disposition", "attachment; filename=facts.csv");
        $serializers.to-csv($result)
    }
    case "excel" return {
        response:content-type("application/vnd.ms-excel");
        response:header("Content-Disposition", "attachment; filename=fact.csv");
        $serializers.to-csv($result)
    }
    default return {
        response:content-type("application/json");
        response:serialization-parameters({"indent" : true});
        {|
            session:comment("json", $comment),
            $result
        |}
    }
};

