jsoniq version "1.0";

module namespace util = "http://secxbrl.info/modules/util";


import module namespace session = "http://apps.28.io/session";
import module namespace response = "http://www.28msec.com/modules/http-response";
import module namespace request = "http://www.28msec.com/modules/http-request";

import module namespace facts = "http://xbrl.io/modules/bizql/facts";
import module namespace entities = "http://xbrl.io/modules/bizql/entities";
import module namespace archives = "http://xbrl.io/modules/bizql/archives";
import module namespace companies = "http://xbrl.io/modules/bizql/profiles/sec/companies";
import module namespace sec-fiscal = "http://xbrl.io/modules/bizql/profiles/sec/fiscal/core";

declare %an:sequential function util:check-and-return-results(
    $entities as object*,
    $results as item*,
    $format as string
)
{
    switch(session:check-access($entities, "data_sec"))
    case $session:ACCESS-ALLOWED return
        $results
    case $session:ACCESS-DENIED return {
          response:status-code(403);
          session:error("accessing filings of an entity that is not in the DOW30", $format)
       }
    case $session:ACCESS-AUTH-REQUIRED return {
          response:status-code(401);
          session:error("authentication required or session expired", $format)
       }
    default return error()
};

declare function util:entities-from-parameters(
    $parameters as object,
    $options as object?) as object*
{
    if ($parameters.Tags[] = "ALL")
    then companies:companies()
    else (
        companies:companies($parameters.CIKs[]),
        companies:companies-for-tags($parameters.Tags[]),
        companies:companies-for-tickers($parameters.Tickers[]),
        companies:companies-for-SIC($parameters.SICs[])
    ),
    if($options.ResolveArchives )
    then entities:entities(archives:entities($parameters.AIDs[]))
    else ()
};

declare function util:filings-from-parameters(
    $parameters as object,
    $options as object?) as object*
{
    let $fy := $parameters.FiscalYears[]
    let $fp := $parameters.FiscalPeriods[]
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    for $entity in util:entities-from-parameters($parameters, { ResolveArchives: false })
    return (
        if(deep-equal($fy, "LATEST"))
        then util:latest-filings($entity, $fp)
        else sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-periods, $fiscal-years),
        archives:archives($parameters.AIDs[])
    )
};

declare function util:filings(
    $entities as object*,
    $fp as string*,
    $fy as string*) as object*
{
    for $entity in $entities
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    let $filings := sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-periods, $fiscal-years)
    return
        if(deep-equal($fy, "LATEST"))
        then $latest-filings
        else $filings
};

declare function util:latest-filings(
    $entities as object*,
    $fiscal-periods as string*)
{
    for $entity in $entities
    for $fiscal-period in $fiscal-periods 
    let $latest-fiscal-year :=
        if ($fiscal-period eq "FY")
        then sec-fiscal:latest-reported-fiscal-period($entity, "10-K").year 
        else sec-fiscal:latest-reported-fiscal-period($entity, "10-Q").year
    return sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-period, $latest-fiscal-year cast as integer)
};

declare function util:filter-override(
    $entities as object*,
    $fp as string*,
    $fy as string*,
    $aids as item*) as object?
{
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    return
    switch(true)
    case exists($aids) return {
        "sec:Archive" : {
            Type: "string",
            Domain : [ $aids ]
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case deep-equal($fy, "LATEST")
    return {
        "sec:Archive" : {
            Type: "string",
            Domain : [archives:aid($latest-filings)]
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case exists(($entities, $fiscal-years, $fiscal-periods))
    return {
        "xbrl:Entity" : {|
            {
                Type: "string",
                Domain: [ $entities._id ]
            }[exists($entities)]
        |},
        "sec:FiscalYear" : {|
            {
                Type: "integer",
                Domain: [ $fiscal-years ]
            }[exists($fiscal-years)]
        |},
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |},
        "sec:Archive" : {}
    }
    default return ()
};

declare function util:parameters() as object
{
    let $format as string?        := request:param-values("format")
    let $ciks as string*          := distinct-values(request:param-values("cik"))
    let $tags as string*          := distinct-values(request:param-values("tag"))
    let $tickers as string*       := distinct-values(request:param-values("ticker"))
    let $sics as string*          := distinct-values(request:param-values("sic"))
    let $fiscalYears as string*   := distinct-values(request:param-values("fiscalYear"))
    let $fiscalPeriods as string* := distinct-values(request:param-values("fiscalPeriod"))
    let $aids as string*          := distinct-values(request:param-values("aid"))
    let $role as string?          := request:param-values("networkIdentifier")
    let $cid as string?           := request:param-values("cid")
    let $concepts as string*      := distinct-values(request:param-values("concept"))
    let $rollups as string*       := distinct-values(request:param-values("rollup"))
    let $map as string?           := request:param-values("map")
    let $disclosure as string?    := request:param-values("disclosure")
    let $validate as string       := request:param-values("validate", "false")
    let $eliminate as string      := request:param-values("eliminate", "false")
    let $report as string?        := request:param-values("report")
    return {|
        {
            CIKs: [ $ciks ],
            Tags: [ $tags ],
            Tickers: [ $tickers ],
            SICs: [ $sics ],
            FiscalYears: [ $fiscalYears ],
            FiscalPeriods: [ $fiscalPeriods ],
            AIDs: [ $aids ],
            CIDs: [ $cid ],
            Concepts: [ $concepts ],
            RollUps: [ $rollups ],
            Disclosure: [ $disclosure ]
        },
        { Format: $format }[exists($format)],
        { Role: $role}[exists($role)],
        { Map: $map }[exists($map)],
        { Validate: $validate }[exists($validate)],
        { Eliminate: $eliminate }[exists($eliminate)],
        { Report: $report }[exists($report)] 
    |}
};

declare function util:process-parameters($parameters as object) as object
{
    let $format as string? :=
        lower-case(($parameters.Format, substring-after(request:path(), ".jq."))[1])
    let $ciks as string* :=
        companies:eid($parameters.CIKs[])
    let $tags as string* :=
        distinct-values($parameters.Tags[] ! upper-case($$))
    let $fiscalYears as atomic* :=
        distinct-values(
        for $y in $parameters.FiscalYears[]
        return
            if ($y eq "LATEST" or $y eq "ALL")
            then $y
            else if ($y castable as integer)
            then integer($y)
            else ()
        )
    let $fiscalPeriods as atomic* :=
            if (($parameters.FiscalPeriods[] ! lower-case($$)) = "all")
            then $sec-fiscal:ALL_FISCAL_PERIODS
            else $parameters.FiscalPeriods[]
    let $aids as string* := archives:aid($parameters.AIDs[])
    let $validate as boolean := $parameters.Validate = "true"
    let $eliminate as boolean := $parameters.Eliminate = "true"

    return facts:merge-objects({|
        {
            CIKs: [ $ciks ],
            Tags: [ $tags ],
            FiscalYears: [ $fiscalYears ],
            FiscalPeriods: [ $fiscalPeriods ],
            AIDs: [ $aids ],
            Validate: $validate,
            Eliminate: $eliminate
        },
        { Format: $format}[exists($format)]
    |}, $parameters, true)
};
