jsoniq version "1.0";

module namespace util = "http://secxbrl.info/modules/util";


import module namespace session = "http://apps.28.io/session";
import module namespace response = "http://www.28msec.com/modules/http-response";
import module namespace request = "http://www.28msec.com/modules/http-request";

import module namespace entities = "http://xbrl.io/modules/bizql/entities";
import module namespace archives = "http://xbrl.io/modules/bizql/archives";
import module namespace companies = "http://xbrl.io/modules/bizql/profiles/sec/companies";
import module namespace sec-fiscal = "http://xbrl.io/modules/bizql/profiles/sec/fiscal/core";

declare %an:sequential function util:check-and-return-results(
    $entities as object*,
    $results as item*,
    $format as string
)
{
    switch(session:check-access($entities, "data_sec"))
    case $session:ACCESS-ALLOWED return
        $results
    case $session:ACCESS-DENIED return {
          response:status-code(403);
          session:error("accessing filings of an entity that is not in the DOW30", $format)
       }
    case $session:ACCESS-AUTH-REQUIRED return {
          response:status-code(401);
          session:error("authentication required or session expired", $format)
       }
    default return error()
};

declare function util:entities(
    $ciks as string*,
    $tags as string*,
    $tickers as string*,
    $sics as string*,
    $aids as string*) as object*
{
    if ($tags = "ALL")
        then companies:companies()
        else (
            companies:companies($ciks),
            companies:companies-for-tags($tags),
            companies:companies-for-tickers($tickers),
            companies:companies-for-SIC($sics)
        ),
    entities:entities(archives:entities($aids))
};

declare function util:filings(
    $entities as object*,
    $fp as string*,
    $fy as string*) as object*
{
    for $entity in $entities
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    let $filings := sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-periods, $fiscal-years)
    return
        if(deep-equal($fy, "LATEST"))
        then $latest-filings
        else $filings
};

declare function util:latest-filings(
    $entities as object*,
    $fiscal-periods as string*)
{
    for $entity in $entities
    for $fiscal-period in $fiscal-periods 
    let $latest-fiscal-year :=
        if ($fiscal-period eq "FY")
        then sec-fiscal:latest-reported-fiscal-period($entity, "10-K").year 
        else sec-fiscal:latest-reported-fiscal-period($entity, "10-Q").year
    return sec-fiscal:filings-for-entities-and-fiscal-periods-and-years($entity, $fiscal-period, $latest-fiscal-year cast as integer)
};

declare function util:filter-override(
    $entities as object*,
    $fp as string*,
    $fy as string*,
    $aids as item*) as object?
{
    let $latest-filings := util:latest-filings($entities, $fp)
    let $fiscal-years as integer* :=
        switch(true)
        case $fy = "ALL" return ()
        default return distinct-values(
            $fy[$$ ne "LATEST"] ! ($$ cast as integer)
        )
    let $fiscal-periods as string* := switch(true)
                         case $fp = "ALL" return ()
                         default return distinct-values($fp)
    return
    switch(true)
    case exists($aids) return {
        "sec:Archive" : {
            Type: "string",
            Domain : [ $aids ]
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case deep-equal($fy, "LATEST")
    return {
        "sec:Archive" : {
            Type: "string",
            Domain : [archives:aid($latest-filings)]
        },
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |}
    }
    case exists(($entities, $fiscal-years, $fiscal-periods))
    return {
        "xbrl:Entity" : {|
            {
                Type: "string",
                Domain: [ $entities._id ]
            }[exists($entities)]
        |},
        "sec:FiscalYear" : {|
            {
                Type: "integer",
                Domain: [ $fiscal-years ]
            }[exists($fiscal-years)]
        |},
        "sec:FiscalPeriod" : {|
            {
                Type: "string",
                Domain: [ $fiscal-periods ]
            }[exists($fiscal-periods)]
        |},
        "sec:Archive" : {}
    }
    default return ()
};

declare function util:parameters() as object
{
    let $format as string? :=
        lower-case((request:param-values("format"), substring-after(request:path(), ".jq."))[1])
    let $ciks as string* :=
        distinct-values(companies:eid(request:param-values("cik")))
    let $tags as string* :=
        distinct-values(request:param-values("tag") ! upper-case($$))
    let $tickers as string* :=
        distinct-values(request:param-values("ticker"))
    let $sics as string* :=
        distinct-values(request:param-values("sic"))
    let $fiscalYears as atomic* :=
        distinct-values(
        for $y in request:param-values("fiscalYear", "LATEST")
        return
            if ($y eq "LATEST" or $y eq "ALL")
            then $y
            else if ($y castable as integer)
            then integer($y)
            else ()
        )
    let $fiscalPeriods as atomic* :=
        distinct-values(let $fp := request:param-values("fiscalPeriod", "FY")
            return
            if (($fp ! lower-case($$)) = "all")
            then $sec-fiscal:ALL_FISCAL_PERIODS
            else $fp)
    let $aids as string* := archives:aid(request:param-values("aid"))
    let $roles as string* := request:param-values("networkIdentifier")
    let $cid as string* := request:param-values("cid")
    let $concepts as string* := distinct-values(request:param-values("concept"))
    let $rollups as string* := distinct-values(request:param-values("rollup"))
    let $map as string? := request:param-values("map")
    let $disclosures as string* := request:param-values("disclosure")
    let $validate as boolean := (request:param-values("validate", "false") = "true")
    let $eliminate as boolean := (request:param-values("eliminate", "false") = "true")
    let $report as string? := request:param-values("report")
    return {
        Format: $format,
        CIKs: [ $ciks ],
        Tags: [ $tags ],
        Tickers: [ $tickers ],
        SICs: [ $sics ],
        FiscalYears: [ $fiscalYears ],
        FiscalPeriods: [ $fiscalPeriods ],
        AIDs: [ $aids ],
        Roles: [ $roles ],
        CIDs: [ $cid ],
        Concepts: [ $concepts ],
        RollUps: [ $rollups ],
        Map: $map,
        Disclosures: [ $disclosures ],
        Validate: $validate,
        Eliminate: $eliminate,
        Report: $report 
    }
};
