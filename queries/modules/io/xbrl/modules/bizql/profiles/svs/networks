jsoniq version "1.0";

(:
 : Copyright 2012-2013 28msec Inc.
 :)

(:~
 : <p>This module provides functionality for querying SVS networks in SVS filings.</p>
 : <p>SVS Networks are actually XBRL Components. In the SVS profiles, all XBRL networks
 : in an XBRL component must be consistent to each other. A way to look at it is that
 : the SVS Network can be identified with the XBRL presentation network it contains.</p>
 : 
 : <p>For XBRL-generic operations on XBRL components, use the
 : generic components module.</p>
 :
 : @author Charles Hoffman
 : @author Matthias Brantner
 : @author Dennis Knochenwefel
 : @author Ghislain Fourny
 : @author Federico Cavalieri
 :)
module namespace svs-networks = "http://xbrl.io/modules/bizql/profiles/svs/networks";

import module namespace mongo = "http://www.28msec.com/modules/mongodb";
import module namespace credentials = "http://www.28msec.com/modules/credentials";

import module namespace archives = "http://xbrl.io/modules/bizql/archives";
import module namespace components = "http://xbrl.io/modules/bizql/components";
import module namespace facts = "http://xbrl.io/modules/bizql/facts";
import module namespace networks = "http://xbrl.io/modules/bizql/networks";
import module namespace hypercubes = "http://xbrl.io/modules/bizql/hypercubes";

import module namespace core = "http://xbrl.io/modules/bizql/profiles/svs/core";

declare namespace ver = "http://zorba.io/options/versioning";
declare option ver:module-version "1.0";

(:~
 : Disclosure for the balance sheet.
 :)
declare variable $svs-networks:BALANCE_SHEET as xs:string := "BalanceSheet";

(:~
 : Disclosure for the parenthetical balance sheet.
 :)
declare variable $svs-networks:BALANCE_SHEET_PARENTHETICAL as xs:string := "BalanceSheetParenthetical";

(:~
 : Disclosure for the income statement.
 :)
declare variable $svs-networks:INCOME_STATEMENT as xs:string := "IncomeStatement";

(:~
 : Disclosure for the parenthetical income statement.
 :)
declare variable $svs-networks:INCOME_STATEMENT_PARENTHETICAL as xs:string := "IncomeStatementParenthetical";

(:~
 : Disclosure for the statement of comprehensive income.
 :)
declare variable $svs-networks:STATEMENT_OF_COMPREHENSIVE_INCOME as xs:string := "StatementOfComprehensiveIncome";

(:~
 : Disclosure for the cash flow statement.
 :)
declare variable $svs-networks:CASH_FLOW_STATEMENT as xs:string := "CashFlowStatement";

(:~
 : Disclosure for the parenthetical cash flow statement.
 :)
declare variable $svs-networks:CASH_FLOW_STATEMENT_PARENTHETICAL as xs:string := "CashFlowStatementParenthetical";

(:~
 : Disclosure for the default component.
 :)
declare variable $svs-networks:DEFAULT_COMPONENT as xs:string := "DefaultComponent";

(:~
 : Disclosure for the document and entity information
 :)
declare variable $svs-networks:DOCUMENT_AND_ENTITY_INFO as xs:string := "DocumentAndEntityInformation";

(:~
 : <p>Retrieves all SVS Networks in a given filing.</p>
 : 
 : @param $archive-or-ids an arbitrary number of archive identifiers (AIDs) 
 :                          or archive objects. 
 :
 : @return all networks in the supplied filings.
 :) 
declare function svs-networks:networks-for-filings(
    $archives-or-ids as item*) as object*
{
  components:components-for-archives($archives-or-ids)
};

(:~
 : <p>Retrieves all SVS Networks that bear the supplied disclosures.</p>
 : 
 : @param $disclosure a list of disclosures.
 :
 : @return all models that match one of the disclosures.
 :) 
declare function svs-networks:networks-for-disclosures(
    $disclosures as string*) as object*
{
  let $conn := svs-networks:connection()
  for $disclosure in $disclosures
  return mongo:find($conn, $components:col, { "Profiles.SVS.Disclosure": $disclosure })
};

(:~
 : <p>Retrieves all models that belong to the archives given as first
 : parameter and that match the supplied disclosures.</p>
 : 
 : @param $archive-or-ids an arbitrary number of archive identifiers (AIDs) 
 :                          or archive objects. 
 : @param $disclosures a list of disclosures.
 :
 : @return all models in the archives and that match one of the disclosures.
 :) 
declare function svs-networks:networks-for-filings-and-disclosures(
    $archive-or-ids as item*,
    $disclosures as string*) as object*
{
(: TODO optimize to a single query :)
  let $conn := svs-networks:connection()
  for $aid_or_archive in $archive-or-ids
  let $aid as atomic := archives:aid($aid_or_archive)
  for $disclosure in $disclosures
  return mongo:find($conn, $components:col, {
    $components:ARCHIVE: $aid,
    "Profiles.SVS.Disclosure": $disclosure
  })
};

(:~
 : <p>Retrieves all models that belong to the archives given as first
 : parameter and that match the supplied category.</p>
 :
 : <p>A category can be any of "Statement", "Disclosure", "Document",
 : "Schedule", or "Unknown".</p>
 : 
 : @param $archive-or-ids an arbitrary number of archive identifiers (AIDs) 
 :                          or archive objects. 
 : @param $categories a list of categories.
 :
 : @return all said models
 :) 
declare function svs-networks:networks-for-filings-and-categories(
    $archive-or-ids as item*,
    $categories as string*) as object*
{
  let $conn := svs-networks:connection()
  for $aid_or_archive in $archive-or-ids
  let $aid as atomic := archives:aid($aid_or_archive)
  for $category in $categories
  return mongo:find($conn, $components:col, {
    $components:ARCHIVE: $aid,
    "Profiles.SVS.Category": $category
  })
};

(:~
:)
declare %private function svs-networks:model-structures-recursive(
    $component as object,
    $xbrl-concepts as object*,
    $ancestor as string,
    $depth as integer)
    as object*
{
  for $xbrl-concept in $xbrl-concepts
  order by $xbrl-concept.Order
  let $main-object := hypercubes:hypercubes-for-components($component, "xbrl:DefaultHypercube")
      .Aspects."xbrl:Concept".Domains."xbrl:ConceptDomain".Members.($xbrl-concept.Name)
  let $kind :=
      switch($main-object.SubstitutionGroup)
      case "xbrldt:hypercubeItem" return "Table"
      case "xbrldt:dimensionItem" return "Axis"
      default return switch($ancestor)
                     case "Table" return "LineItems"
                     case "Axis"
                     case "Member" return "Member"
                     default return if ($main-object.IsAbstract) then "Abstract" else "Concept"
  return {|
    {
      "Kind" : $kind,
      "Name" : $main-object.Name,
      "Label" : $main-object.Label,
      "Depth" : $depth
    },
    if (exists($xbrl-concept.Order))
    then { "Order" : $xbrl-concept.Order }
    else (),
    if ($kind eq "Concept")
    then trim($main-object, ("Name", "Label"))
    else (),
    let $children := svs-networks:model-structures-recursive(
                         $component,
                         values($xbrl-concept.To),
                         $kind,
                         $depth + 1
                     )
    return if (exists($children)) then { Children: [ $children ] } else ()
  |}
};

(:~
 : <p>Computes the model structure of the supplied SVS Network, which is a hierarchy
 : of SVS Report Elements (Tables, Axes, Members, LineItems, Abstracts, Concepts).</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the model structures of these SVS Networks.
 :
 :)
declare function svs-networks:model-structures($networks-or-ids as item*) as object*
{
  for $svs-network in components:components($networks-or-ids)
  let $presentation-network := networks:networks-for-components-and-short-names(
      $svs-network,
      $networks:PRESENTATION_NETWORK)
  return svs-networks:model-structures-recursive(
      $svs-network,
      values($presentation-network.Trees),
      "None",
      1)
};

(:~
 : <p>Returns all SVS Tables contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Tables are XBRL hypercubes.</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @param $options <a href="core#standard_options">standard SVS BizQL options</a>.
 :
 : @return the SVS Tables.
 :
 :)
declare function svs-networks:tables($networks-or-ids as item*, $options as object?) as object*
{
  let $include-implied-table as boolean := if(exists($options("IncludeImpliedTable")))
                                           then $options("IncludeImpliedTable")
                                           else false
  for $model-structure in svs-networks:model-structures($networks-or-ids)
  let $explicit-tables :=
    for $object in
      ($model-structure, descendant-objects($model-structure))[$$.Kind eq "Table"]
    group by $name := $object.Name
    return trim($object[1], "Children")
  return if (exists($explicit-tables) or not $include-implied-table)
         then $explicit-tables
         else {
           Name: "xbrl28:ImpliedTable",
           Label: "BizQL SVS Implied Table"
         }
};

(:~
 : <p>Returns all SVS Tables contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Tables are XBRL hypercubes.</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Tables.
 :
 :)
declare function svs-networks:tables($networks-or-ids as item*) as object*
{
  svs-networks:tables($networks-or-ids, ())
};

(:~
 : <p>Returns all SVS Axes contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Axes are XBRL dimensions.</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Axes.
 :
 :)
declare function svs-networks:axes($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind eq "Axis"]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : <p>Returns all SVS Members contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Members are XBRL members that are in the transitive closure of SVS Axes
 : via the dimension-domain and domain-member relations.</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Members.
 :
 :)
declare function svs-networks:members($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind eq "Member"]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : <p>Returns all SVS LineItems report elements contained in the supplied SVS Networks.</p>
 : <p>This is not to be confused with the "line items" terminology, which includes all
 : SVS Abstracts and SVS Concepts.</p>
 :
 : <p>SVS LineItems report elements are XBRL abstract primary items that are top-level in their
 : association with an XBRL hypercube (source of an all relation).</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS LineItems report elements.
 :
 :)
declare function svs-networks:line-items-report-elements($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind eq "LineItems"]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : <p>Returns all SVS Abstracts contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Abstracts are XBRL abstract primary items that may or may not be associated
 : with a hypercube -- except those that are SVS LineItems (i.e., source of an all relation).</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Abstracts.
 :
 :)
declare function svs-networks:abstracts($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind eq "Abstract"]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : <p>Returns all SVS Concepts contained in the supplied SVS Networks.</p>
 :
 : <p>SVS Concepts are XBRL concrete primary items that may or may not be associated
 : with a hypercube.</p>
 : 
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Concepts.
 :
 :)
declare function svs-networks:concepts($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind eq "Concept"]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : <p>Returns all SVS Line Items (Concepts and Abstracts) contained in the
 : supplied SVS Networks. Not to be confused with the LineItems report element.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the SVS Line Items.
 :
 :)
declare function svs-networks:line-items($networks-or-ids as item*) as object*
{
  let $model-structure := svs-networks:model-structures($networks-or-ids)
  for $object in
    ($model-structure, descendant-objects($model-structure))[$$.Kind = ("Concept", "Abstract")]
  group by $name := $object.Name
  return trim($object[1], "Children")
};

(:~
 : Return the number of SVS Tables in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of tables
 :)
declare function svs-networks:num-tables($networks-or-ids as item*) as integer*
{
  components:num-hypercubes($networks-or-ids)
};

(:~
 : Return the number of (distinct) SVS report elements in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of report elements
 :)
declare function svs-networks:num-report-elements($networks-or-ids as item*) as integer*
{
  for $c in components:components($networks-or-ids)
  return sum(
    (
      components:num-concrete-primary-items-in-hypercubes($c),
      components:num-abstract-primary-items-in-hypercubes($c),
      components:num-concrete-primary-items-not-in-hypercubes($c),
      components:num-distinct-abstract-primary-items-not-in-hypercubes($c)
    )
  )
};

(:~
 : Return the number of (distinct) SVS Axes in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of axes
 :)
declare function svs-networks:num-axes($networks-or-ids as item*) as integer*
{
  components:num-explicit-dimensions($networks-or-ids)
};

(:~
 : Return the number of (distinct) SVS Members in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of members
 :)
declare function svs-networks:num-members($networks-or-ids as item*) as integer*
{
  for $c in components:components($networks-or-ids)
  return $c.Statistics.NumDistinctMembers
};

(:~
 : Return the number of (distinct) SVS LineItems report elements in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of line items
 :)
declare function svs-networks:num-line-items($networks-or-ids as item*) as integer*
{
  components:components($networks-or-ids) ! $$.Statistics.Profiles.SVS.NumDistinctReportElementNamesEndingWithLineItems
};

(:~
 : Return the number of (distinct) SVS Abstracts in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of abstracts
 :)
declare function svs-networks:num-abstracts($networks-or-ids as item*) as integer*
{
  for $c in components:components($networks-or-ids)
  let $s := $c.Statistics
  return  $s.NumDistinctAbstractPrimaryItemsInHypercubes
          + $s.NumDistinctAbstractPrimaryItemsNotInHypercubes
          - $s.Profiles.SVS.NumDistinctReportElementNamesEndingWithLineItems
};

(:~
 : Return the number of (distinct) SVS Concepts in each of the given components.
 :
 : @param $networks-or-ids list of components or IDs
 :
 : @return the said number of concepts
 :)
declare function svs-networks:num-concepts($networks-or-ids as item*) as integer*
{
  for $c in components:components($networks-or-ids)
  let $s := $c.Statistics
  return  $s.NumDistinctConcretePrimaryItemsInHypercubes
          + $s.NumDistinctConcretePrimaryItemsNotInHypercubes
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Network.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @return a sequence of facts.
 :)
declare function svs-networks:facts(
    $networks-or-ids as item*
)
as object*
{
  svs-networks:facts($networks-or-ids, ())
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Network.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @return a array populated with fact values.
 :)
declare function svs-networks:fact-tables(
    $networks-or-ids as item*
)
as array
{
  svs-networks:fact-tables($networks-or-ids, ())
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Networks and populates the model structures.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the populated model structures (Facts array fields).
 :)
declare function svs-networks:populated-model-structures(
    $networks-or-ids as item*
)
as object*
{
  svs-networks:populated-model-structures($networks-or-ids, ())
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Network.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @param $options <a href="core#standard_options">standard SVS BizQL options</a>.
 :
 : @return a sequence of facts.
 :)
declare function svs-networks:facts(
    $networks-or-ids as item*,
    $options as object?
)
as object*
{
  for $component as object in components:components($networks-or-ids)
  for $table as string? allowing empty in svs-networks:tables($component).Name
  let $hypercube as object? := hypercubes:hypercubes-for-components($component, $table)
  let $hypercube as object := if (exists($hypercube))
                              then $hypercube
                              else core:dimensionless-hypercube({
                                  Concepts: [ svs-networks:line-items($component).Name ]
                              })
  let $facts := hypercubes:facts-for-hypercube(
    $hypercube,
    $component.Archive,
    if (exists($options.Filter.Profiles.SVS.Fiscal))
    then $options
    else facts:merge-objects(
        { Filter: { "Profiles.SVS.Fiscal" : { "$exists" : true } } },
        $options,
        true
    )
  )
  let $hide-amended-facts as boolean := 
    if (exists($options.HideAmendedFacts))
    then $options.HideAmendedFacts
    else true (: default :)
  return
    if ($hide-amended-facts)
    then core:hide-amended-facts($facts)
    else $facts
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Network.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @param $options <a href="core#standard_options">standard SVS BizQL options</a>.
 :
 : @return a array of arrays filled with fact values.
 :)
declare function svs-networks:fact-tables(
    $networks-or-ids as item*,
    $options as object?
)
as array
{
  for $component as object in components:components($networks-or-ids)
  for $table as string? allowing empty in svs-networks:tables($component).Name
  let $hypercube as object? := hypercubes:hypercubes-for-components($component, $table)
  let $hypercube as object := if (exists($hypercube))
                              then $hypercube
                              else core:dimensionless-hypercube({
                                  Concepts: [ svs-networks:line-items($component).Name ]
                              })
  return hypercubes:fact-table-for-hypercube(
      $hypercube,
      $component.Archive,
      {|
        $options,
        { "facts-for-archives-and-concepts": core:facts-for-archives-and-concepts#3 }
      |}
  )
};

(:~
 :
 : <p>Retrieves all facts belonging to the SVS Networks and populates the model structures.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @param $options <a href="core#standard_options">standard SVS BizQL options</a>.
 :
 : @return the populated model structures (Facts array fields).
 :)
declare function svs-networks:populated-model-structures(
    $networks-or-ids as item*,
    $options as object?
)
as object*
{
  let $fact-table-by-concepts := {|
    for $f in svs-networks:facts($networks-or-ids, $options)
    group by $concept := $f.Aspects."xbrl:Concept"
    return { $concept : [ $f ] }
  |}
  return
    copy $result := svs-networks:model-structures($networks-or-ids)
    modify
      for $concept in ($result, descendant-objects(values($result)))[$$.Kind eq "Concept"]
      let $name := $concept.Name
      return insert json { "Facts" : $fact-table-by-concepts.$name } into $concept
    return $result
};

(:~
 : 
 : <p>Returns the disclosures of the suplied networks.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 : @return the disclosure names, or "UncategorizedInformation" if none.
 : 
 :)
declare function svs-networks:disclosures($networks-or-ids as item*) as string+
{
  for $component in components:components($networks-or-ids)
  let $disclosure := $component.Profiles.SVS.Disclosure
  return if (exists($disclosure)) 
         then $disclosure
         else "UncategorizedInformation"
};

(:~
 :
 : <p>Return the categories of the supplied SVS networks (Statement, Disclosure, Document or Schedule).</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the category of each network.
 :)
declare function svs-networks:categories($networks-or-ids as item*) as string*
{
  let $component := components:components($networks-or-ids)
  return normalize-space(tokenize($component.Label, "-")[2])
};

(:~
 :
 : <p>Return the sub-categories of the supplied SVS networks (Detail, TextBlockLevel4, TextBLockLevel1to3).</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return the sub-category of each network.
 :)
declare function svs-networks:sub-categories($networks-or-ids as item*) as string*
{
  for $network in $networks-or-ids
  let $numbers :=
    for $concept in svs-networks:concepts($network)
    group by $is-text-block := $concept.IsTextBlock
    return {
      if($is-text-block) then "TextBlocks" else "NonTextBlocks": count($concept)
    }
  return switch(true)
         case $numbers.NonTextBlocks gt 0 and not $numbers.TextBlocks gt 0 return "Detail"
         case $numbers.NonTextBlocks gt 0 return "TextBlockLevel4"
         case $numbers.TextBlocks gt 0 return "TextBlockLevel1To3"
         default return "Unknown"
};

(:~
 :
 : <p>Return summary information for the supplied SVS networks.</p>
 :
 : @param $networks-or-ids a sequence of SVS Network objects, or their XBRL Component IDs.
 :
 : @return one object per network, containing a summary.
 :)
declare function svs-networks:summaries($networks-or-ids as item*) as object*
{
  for $component in components:components($networks-or-ids)
  return {
    ComponentId : $component._id,
    AccessionNumber : $component.Archive,
    NetworkLabel : $component.Label,
    NetworkIdentifier : $component.Role,
    Category : svs-networks:categories($component),
    SubCategory : svs-networks:sub-categories($component),
    Table : [ svs-networks:tables($component, { IncludeImplifiedTable: true }).Name ],
    Disclosure : svs-networks:disclosures($component)
  }
};

(:~
 :)
declare %private function svs-networks:connection() as anyURI
{
  let $credentials :=
      let $credentials := credentials:credentials("MongoDB", "xbrl")
      return if (empty($credentials))
             then error(QName("svs-networks:CONNECTION-FAILED"), "no xbrl MongoDB configured")
             else $credentials
  return
    try {
      mongo:connect($credentials)
    } catch mongo:* {
      error(QName("svs-networks:CONNECTION-FAILED"), $err:description)
    }
};
