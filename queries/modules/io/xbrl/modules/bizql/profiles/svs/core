jsoniq version "1.0";
(: SVS, fix when RUT are properly formatted :)

(:
 : Copyright 2012-2013 28msec Inc.
 :)

(:~
 : <p>This module provides functionality for querying XBRL Models of financial reports submitted to the SVS.
 : </p>
 :
 : <h2 id="standard_options">Standard <code>$options</code> Parameter</h2>
 :
 : <p>Most functions in the BizQL package allow an additional <code>$options</code>
 :    parameter. The options parameter is a JSON object which is defined in the documentation
 :    of the <a href="../../facts#standard_options">facts module</a>.</p>
 :
 : <p>In addition to the option fields defined in the 
 :    <a href="../../facts#standard_options">facts module</a> the following 
 :    fields can be used in the options of a function in the SVS profile:</p>
 : 
 : <ul>
 : <li><b>HideAmendedFacts</b>: if set to true (default behavior) all facts that have been
 :     amended are not included in the result.</li>
 : <li><b>IncludeImpliedTable</b>: set to true in order to output the implied table if 
 :     there is no Table (default is false).</li>
 : </ul>
 :
 : @author Charles Hoffman
 : @author Matthias Brantner
 : @author Dennis Knochenwefel
 : @author Ghislain Fourny
 : @author Federico Cavalieri
 :)
module namespace svs = "http://xbrl.io/modules/bizql/profiles/svs/core";

import module namespace string = "http://zorba.io/modules/string";

import module namespace m = "http://www.28msec.com/modules/mongodb";
import module namespace credentials = "http://www.28msec.com/modules/credentials";

import module namespace entities = "http://xbrl.io/modules/bizql/entities";
import module namespace archives = "http://xbrl.io/modules/bizql/archives";
import module namespace facts = "http://xbrl.io/modules/bizql/facts";
import module namespace hypercubes = "http://xbrl.io/modules/bizql/hypercubes";
import module namespace networks = "http://xbrl.io/modules/bizql/networks";
import module namespace report-schemas = "http://xbrl.io/modules/bizql/report-schemas";
import module namespace concept-maps = "http://xbrl.io/modules/bizql/concept-maps";

declare namespace ver = "http://zorba.io/options/versioning";
declare option ver:module-version "1.0";

(:~
 : Scheme for the SVS entity identifiers (i.e. http://www.svs.cl/rut)
 :)
declare variable $svs:RUT as xs:string := "http://www.svs.cl/rut";

(:~
 : Joker value for all archives or all concepts.
 :)
declare variable $svs:ALL_OF_THEM as boolean := true;

(:~
 : All prefixes pre-declared in SVS's EDGAR.
 :)
declare variable $svs:EDGAR_PREFIXES :=
  ( "xbrli", "link", "xl", "xlink", "xbrldt", "xbrldi", "nonnum", 
    "num", "ref", "us-gaap", "dei", "us-types", "invest", "country", 
    "currency", "exch", "naics", "sic", "stpr", "rr", "rr-ent", 
    "rr-cal", "rr-def", "rr-pre" );

(:~
 : <p>Return all facts that match a given filter object optionally interpreted
 :    in the context of an optionally given hypercube.
 :    Only returns the facts that match the fiscal focus of the archive they
 :    belong to.</p>
 :
 : @param $options <a href="#standard_options">standard fact retrieving options</a>.
 :
 : @error facts:INVALID-RULE-TYPE the type of a rule is not unknown/invalid
 : @error facts:RULE-EXECUTION-ERROR a rule raised an error whilst being executed
 : @error facts:FILTER-TOO-GENERIC The filter object must have at least one of the 
 :        fields Archive, Aspects.xbrl:Concept, Aspects.xbrl:Period, or 
 :        Aspects.xbrl:Entity.
 : @return all facts satisfying the filter and options.
 :) 
declare function svs:facts-for(
  $options as object?) as object*
{
  let $facts := facts:facts-for(
    if (exists($options.Filter.Profiles.SVS.Fiscal))
    then $options
    else facts:merge-objects(
        { Filter: { "Profiles.SVS.Fiscal" : { "$exists" : true } } },
        $options,
        true
    )
  )
  let $hide-amended-facts as boolean := 
    if (exists($options.HideAmendedFacts))
    then $options.HideAmendedFacts
    else true
  return
    if ($hide-amended-facts)
    then svs:hide-amended-facts($facts)
    else $facts
};

(:~
 :
 : <p>Retrieves all facts in the supplied hypercube, across all archives.</p>
 : <p>Default values will be populated automatically.</p>
 : <p>Only returns the facts that match the fiscal focus of the archive they
 :    belong to.</p>
 : 
 :
 : @param $hypercube a hypercube.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:facts-for-hypercube(
    $hypercube as object
)
as object*
{
  svs:facts-for({ Hypercube: $hypercube })
};

(:~
 :
 : <p>Retrieves all facts in the supplied hypercube, across all archives.</p>
 : <p>Default values will be populated automatically.</p>
 : <p>Only returns the facts that match the fiscal focus of the archive they
 :    belong to.</p>
 : 
 :
 : @param $hypercube a hypercube.
 : @param $options <a href="facts#standard_options">standard fact retrieving options</a>.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:facts-for-hypercube(
    $hypercube as object,
    $options as object?
)
as object*
{
  let $options as object := facts:merge-objects(
    { Hypercube: $hypercube },
    $options,
    true
  )
  return svs:facts-for($options)
};

(:~
 : <p>Retrieves the facts associated with the supplied concepts
 : from the supplied archive, that match the fiscal focus of the archive.</p>
 : 
 : @param $archive_or_ids a sequence of archives or their ids or $svs:ALL_OF_THEM for no filtering.
 : @param $concepts the concepts or $svs:ALL_OF_THEM for no filtering.
 :
 : @return the latest facts associated with the supplied concept.
 :) 
declare function svs:facts-for-archives-and-concepts(
    $archive_or_ids as item*,
    $concepts as item*) as object*
{
  svs:facts-for-archives-and-concepts($archive_or_ids, $concepts, ())
};

(:~
 : <p>Retrieves the facts associated with the supplied concepts
 : from the supplied archive, that match the fiscal focus of the archive.</p>
 : 
 : @param $archive_or_ids a sequence of archives or their ids or $svs:ALL_OF_THEM for no filtering.
 : @param $concepts the concepts or $svs:ALL_OF_THEM for no filtering.
 : @param $options <a href="#standard_options">standard SVS BizQL options</a>.
 :
 : @return the latest facts associated with the supplied concept.
 :) 
declare function svs:facts-for-archives-and-concepts(
    $archive_or_ids as item*,
    $concepts as item*,
    $options as object?) as object*
{
  let $options := if(empty($options.Hypercube))
                  then facts:merge-objects(
                      {
                          "Hypercube" : svs:dimensionless-hypercube(())
                      },
                      $options,
                      true)
                  else $options
  let $hide-amended-facts as boolean := 
    if (exists($options.HideAmendedFacts))
    then $options.HideAmendedFacts
    else true (: default :)
  let $facts := 
    facts:facts-for-archives-and-concepts(
      $archive_or_ids, 
      $concepts, 
      $options)[
        exists($$.Profiles.SVS.Fiscal)
    ]
  return 
    if ($hide-amended-facts)
    then svs:hide-amended-facts($facts)
    else $facts
};

(:~
 :
 : <p>Filters a list of facts and returns only the latest amending facts.
 :    Accordingly, all amended facts are filtered out.</p>
 : 
 : @param $facts a list of facts.
 :
 : @return a sequence of facts without amended facts.
 :)
declare function svs:hide-amended-facts(
    $facts as object*
)
as object*
{
  for $grouped-facts in $facts
  let $entity as string := $grouped-facts.Aspects."xbrl:Entity"
  let $fiscal-period as string? := $grouped-facts.Profiles.SVS.Fiscal.Period
  let $fiscal-year as integer? := $grouped-facts.Profiles.SVS.Fiscal.Year
  group by $entity, $fiscal-period, $fiscal-year
  return
    if (empty($fiscal-period) or empty($fiscal-year))
    then
      (: $grouped-facts is already grouped by entity.
         Now, group by period as a fallback. :)
      for $regrouped-facts in $grouped-facts
      let $period as string := $regrouped-facts.Aspects."xbrl:Period"
      group by $period
      return
        let $latest-accepted :=
          max(distinct-values($regrouped-facts.Profiles.SVS.Accepted))
        return 
          if (empty($latest-accepted))
          then $regrouped-facts
          else 
            (: hide amended facts :)
            $regrouped-facts[$$.Profiles.SVS.Accepted eq $latest-accepted]

    else
      let $latest-accepted :=
        max(distinct-values($grouped-facts.Profiles.SVS.Accepted))
      return 
        if (empty($latest-accepted))
        then $grouped-facts
        else 
          (: hide amended facts :)
          $grouped-facts[$$.Profiles.SVS.Accepted eq $latest-accepted]
};

(:~
 :
 : <p>Retrieves all facts from the supplied archives, that are relevant to the
 : supplied schema and to the fiscal focus, and populates
 : them with the default dimension values when missing.</p>
 : 
 :
 : @param $schema a schema.
 : @param $archives a sequence of archives or their AIDs or $svs:ALL_OF_THEM for no filtering.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:facts-for-schema(
    $schema as item,
    $archives as item*
)
as object*
{
  svs:facts-for-schema($schema, $archives, ())
};


(:~
 :
 : <p>Retrieves all facts from the supplied archives, that are relevant to the
 : supplied schema and to the fiscal focus, and populates
 : them with the default dimension values when missing.</p>
 : 
 :
 : @param $schema a schema.
 : @param $archives a sequence of archives or their AIDs or $svs:ALL_OF_THEM for no filtering.
 : @param $options <a href="#standard_options">standard SVS BizQL options</a>.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:facts-for-schema(
    $schema as item,
    $archives as item*,
    $options as object?
)
as object*
{
  let $facts := report-schemas:facts($schema, $archives,
    if (exists($options.Filter.Profiles.SVS.Fiscal))
    then $options
    else facts:merge-objects(
        { Filter: { "Profiles.SVS.Fiscal" : { "$exists" : true } } },
        $options,
        true
    )
  )
  let $hide-amended-facts as boolean := 
    if (exists($options.HideAmendedFacts))
    then $options.HideAmendedFacts
    else true (: default :)
  return
    if ($hide-amended-facts)
    then svs:hide-amended-facts($facts)
    else $facts
};


(:~
 :
 : <p>Retrieves all facts from the supplied archives, that are relevant to the
 : supplied schema, and populates them with the default dimension values
 : when missing.</p>
 : 
 :
 : @param $schema a report schema or its RID.
 : @param $archives a sequence of archives or their AIDs or $svs:ALL_OF_THEM for no filtering.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:fact-table-for-schema(
  $schema as item,
  $archives as item*) as array
{
   let $hypercube := hypercubes:hypercubes-for-components(
      report-schemas:report-schemas($schema),
      "xbrl:DefaultHypercube")
   return hypercubes:fact-table-for-hypercube-and-facts(
     $hypercube,
     svs:facts-for-schema($schema, $archives)
   )
};

(:~
 : <p>Populates a concept-tree network with all facts from the supplied archives,
 : that are relevant to the
 : supplied schema. Default dimension values are added to the facts
 : when missing.</p>
 : 
 : @param $schema a report schema or its RID.
 : @param $archives a sequence of archives or their AIDs.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:populate-schema-with-facts(
  $schema as item,
  $archives as item*) as object*
{
  svs:populate-schema-with-facts($schema, $archives,())
};

(:~
 : <p>Populates a concept-tree network with all facts from the supplied archives,
 : that are relevant to the
 : supplied schema. Default dimension values are added to the facts
 : when missing.</p>
 : 
 : @param $schema a report schema or its RID.
 : @param $archives a sequence of archives or their AIDs or $svs:ALL_OF_THEM for no filtering.
 : @param $options <a href="#standard_options">standard SVS BizQL options</a>.
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function svs:populate-schema-with-facts(
  $schema as item,
  $archives as item*,
  $options as object?) as object*
{
  let $networks :=
      networks:networks-for-components-and-short-names($schema, "Presentation")
  return hypercubes:populate-networks-with-retrieved-facts(
    $networks,
    svs:facts-for-schema($schema, $archives, $options)
  )
};

(:~
 : <p>Return all facts for concepts that are defined by one of the common
 : edgar taxonomies. In particular, this function returns facts for concepts
 : having one of the following prefixes:</p>
 :
 : <ul>
 :   <li>xbrli</li>
 :   <li>link</li>
 :   <li>xl</li>
 :   <li>xlink</li>
 :   <li>xbrldt</li>
 :   <li>xbrldi</li>
 :   <li>nonnum</li>
 :   <li>num</li>
 :   <li>ref</li>
 :   <li>us-gaap</li>
 :   <li>dei</li>
 :   <li>us-types</li>
 :   <li>invest</li>
 :   <li>country</li>
 :   <li>currency</li>
 :   <li>exch</li>
 :   <li>naics</li>
 :   <li>sic</li>
 :   <li>stpr</li>
 :   <li>rr</li>
 :   <li>rr-ent</li>
 :   <li>rr-cal</li>
 :   <li>rr-def</li>
 :   <li>rr-pre</li>
 : </ul>
 :
 : @param $archive_or_ids a sequence of archive or archive IDs to filter.
 : @return all facts having one of the above prefixes.
 :) 
declare function svs:edgar-facts-for-archives(
  $archive_or_ids as item*) as object* 
{
  svs:facts-for-archives-and-concepts(
    $archive_or_ids,
    $svs:ALL_OF_THEM,
    {
      Filter: {
        Profiles: {
          svs: {
            IsExtension: false
          }
        }
      }
    })
};

(:~
 : <p>Return all facts for concepts that are NOT defined by one of the common
 : edgar taxonomies. In particular, this function returns facts for concepts
 : having none of the prefixes listed under function 
 : svs:edgar-facts-for-archives.</p>
 :
 : @param $archive_or_ids a sequence of archive or archive IDs to filter.
 : @return all facts having none of the common edgar prefixes.
 :) 
declare function svs:extension-facts-for-archives(
  $archive_or_ids as item*) as object* 
{
  svs:facts-for-archives-and-concepts(
    $archive_or_ids,
    $svs:ALL_OF_THEM,
    {
      Filter: {
        Profiles: {
          svs: {
            IsExtension: true
          }
        }
      }
    })
};

(:~
 : <p>Retrieves the document end date of a filing or a fact.</p>
 : 
 : @param $filing-fact-or-id a filing, a fact, or its id.
 :
 : @return the document end date (e.g., xs:date("2011-04-30")).
 :) 
declare function svs:end-date(
    $filing-fact-or-id as item?) as xs:date?
{
  if (empty($filing-fact-or-id))
  then ()
  else
    typeswitch ($filing-fact-or-id)
    case object return 
      switch (true)
      (: archive :)
      case exists($filing-fact-or-id.Profiles.SVS.Fiscal.DocumentPeriodEndDate)
        return svs:date($filing-fact-or-id.Profiles.SVS.Fiscal.DocumentPeriodEndDate)
      (: fact :)
      case exists($filing-fact-or-id.Profiles.SVS.Fiscal.DocEndDate)
        return svs:date($filing-fact-or-id.Profiles.SVS.Fiscal.DocEndDate)
      default return ()
    default return 
      let $id as xs:string := string($filing-fact-or-id)
	  (:SVS fixme, this can be more robust when RUT are properly formatted :)
      return (svs:date(archives:archives($id).Profiles.SVS.Fiscal.DocumentPeriodEndDate), svs:date(facts:facts($id).Profiles.SVS.Fiscal.DocEndDate))[1]
};

declare function svs:date($date as xs:string) as xs:date
{ 
  if (matches($date, "\\w\\w\\w \\w\\w\\w \\d\\d \\d\\d:\\d\\d:\\d\\d UTC \\d\\d\\d\\d"))
  then
    xs:date(
      substring($date, 25, 4) || "-" ||
      (
        switch (substring($date, 5, 3))
          case "Jan" return "01"
          case "Feb" return "02"
          case "Mar" return "03"
          case "Apr" return "04"
          case "May" return "05"
          case "Jun" return "06"
          case "Jul" return "07"
          case "Aug" return "08"
          case "Sep" return "09"
          case "Oct" return "10"
          case "Nov" return "11"
          case "Dec" return "12"
          default return error(xs:QName("err:FORG0001"), "Cannot parse date")
      ) || "-" ||
      substring($date, 9, 2)
    )
  else xs:date($date)
};

(:~
 : <p>Returns an instantiation of a dimensionless Hypercube containing the basic
 :    characteristics (xbrl:Concept, xbrl:Period, xbrl:Entity, and xbrl:Unit).
 :    For each of those included aspects the value space is not limited, however
 :    you can restrict it using the options. If you need more
 :    XBRL dimensions, use the user-defined-hypercube function instead.</p>
 : <p>In the SVS profile, there is an additional axis that is always here:
 : dei:LegalEntityAxis, with a default value svs:DefaultLegalEntity and a filtering
 : only accepting this default value.</p>
 :
 : @return dimensionless hypercube instantiation.
 : @param $options: additional options among which:
 : - Concepts: an array of concept names to include in the hypercube.
 : - Periods: an array of periods to include in the hypercube.
 : - Entities: an array of EIDs to include in the hypercube.
 : - Units: an array of units to include in the hypercube.
 : - LegalEntities: an array of legal entities to include in the hypercube.
 :)
declare function svs:dimensionless-hypercube($options as object?) as object
{
  svs:user-defined-hypercube(
    {|
      if(exists($options.Concepts))
      then { "xbrl:Concept" : { Domain: $options.Concepts } }
      else (),
      if(exists($options.Entities))
      then { "xbrl:Entity" : { Domain: [ entities:eid($options.Entities[]) ] } }
      else (),
      if(exists($options.Periods))
      then { "xbrl:Period" : { Domain: $options.Periods } }
      else (),
      if(exists($options.Units))
      then { "xbrl:Unit" : { Domain: $options.Units } }
      else (),
      if(exists($options.LegalEntities))
      then { "dei:LegalEntityAxis" : { Domain: $options.LegalEntities } }
      else ()
    |}
  )
};

(:~
 : <p>Returns an instantiation of a Hypercube with no extra dimensions besides the legal entity axis.
 :    The four basic characteristics (xbrl:Concept, xbrl:Period, xbrl:Entity, and xbrl:Unit)
 :    are always added, but can be overriden. For each of those included aspects the value space is,
 :    by default, not limited, and only xbrl:Unit has a default value.</p>
 :    <p>The characteristic dei:LegalEntityAxis is also here. It has
 :    a default value of svs:DefaultLegalEntity and restricts the value
 :    space to this default value.</p>
 :    
 :
 : @return the hypercube instantiation.
 :)
declare function svs:user-defined-hypercube() as object
{
  svs:user-defined-hypercube(())
};

(:~
 : <p>Returns an instantiation of a Hypercube containing the specified dimensions.
 :    The four basic characteristics (xbrl:Concept, xbrl:Period, xbrl:Entity, and xbrl:Unit)
 :    are always added, but can be overriden. For each of those included aspects the value space is,
 :    by default, not limited, and only xbrl:Unit has a default value.</p>
 :    <p>The characteristic dei:LegalEntityAxis is always here, and can be overriden. It has,
 :    by default, a default value of svs:DefaultLegalEntity (which can be overriden or set to null
 :    for no default), and by default restricts the value
 :    space to this default value (which can be overriden or set to null for no filtering).</p>
 :    
 :
 : @return the hypercube instantiation.
 : @param $dimensions: an object with pairs of (dimension name, object with dimension information). These 
 : dimension information subobjects
 : may have two (optional) fields: Default (a string) and Domain (an array of strings).
 :)
declare function svs:user-defined-hypercube($dimensions as object?) as object
{
  let $extended-dimensions := {|
    for $d in distinct-values((
        "dei:LegalEntityAxis",
        keys($dimensions)
    ))
    let $dimension-spec := $dimensions.$d

    let $dimension-default as string? :=
        if ($d eq "dei:LegalEntityAxis" and empty($dimension-spec.Default))
        (: if no default is provided for the legal entity axis, we assume svs:DefaultLegalEntity. :)
        then "svs:DefaultLegalEntity"
        (: if it's provided, we use it, but it it's null there is no default. :)
        else $dimension-spec.Default[$$ ne null]

    let $dimension-domain as array? :=
        if ($d eq "dei:LegalEntityAxis" and
            empty($dimension-spec.Domain) and
            exists($dimension-default))
        (: if no domain is provided for the legal entity axis and there is a default, we assume the default value. :)
        then [ $dimension-default ]
        else typeswitch($dimension-spec.Domain)
             case null return ()
             default return $dimension-spec.Domain

    return {
      $d : {|
        { Domain : $dimension-domain }[exists($dimension-domain)],
        { Default : $dimension-default }[exists($dimension-default)]
      |}
    }
  |}
  return hypercubes:user-defined-hypercube($extended-dimensions)
};
