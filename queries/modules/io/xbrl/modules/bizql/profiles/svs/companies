jsoniq version "1.0";

(:
 : Copyright 2012-2013 28msec Inc.
 :)

(:~
 : <p>This module provides functionality for querying companies (XBRL entities)
 :  submitting to the SVS.</p>
 : <p>SVS Companies are nothing else than XBRL entities. For XBRL-generic requests on
 : entities, use the generic entities module.</p>
 :
 : <p>With this module, you can retrieve a company with its RUT (without converting
 : it to an EID). You can also retrieve companies by sector, by SIC code, by types,
 : by tags, by tickers.</p>
 :
 : @author Charles Hoffman
 : @author Matthias Brantner
 : @author Dennis Knochenwefel
 : @author Ghislain Fourny
 : @author Federico Cavalieri
 :)
module namespace companies = "http://xbrl.io/modules/bizql/profiles/svs/companies";

import module namespace mongo = "http://www.28msec.com/modules/mongodb";
import module namespace credentials = "http://www.28msec.com/modules/credentials";

import module namespace entities = "http://xbrl.io/modules/bizql/entities";
import module namespace svs = "http://xbrl.io/modules/bizql/profiles/svs/core";

declare namespace ver = "http://zorba.io/options/versioning";
declare option ver:module-version "1.0";

(:~
 : <p>Return all companies</p>
 : 
 : @return all companies.
 :) 
declare function companies:companies() as object*
{
  entities:entities()
};

(:~
 : <p>Return the companies with the given identifiers.</p>
 : 
 : @param $companies-or-ids the ids of the companies or the companies themselves.
 :
 : @return the companies with the given identifiers
 :         the empty sequence if no company was found or if the input is an
 :         empty sequence.
 :) 
declare function companies:companies($companies-or-ids as item*) as object*
{
  let $ids as atomic* :=
    for $s in $companies-or-ids
    where $s instance of atomic
    return $s
  let $companies as object* :=
    for $s in $companies-or-ids
    where $s instance of object
    return $s
  return
    (
      $companies,
      if (exists($ids))
      then
        let $conn := companies:connection()
        return mongo:find($conn, $entities:col, { "_id" : { "$in" : [ $ids ! companies:eid($$) ] } })
      else ()
    )
};

(:~
 : <p>Retrieves the type of a company.</p>
 : 
 : @param $companies-or-ruts a sequence of companies or their identifiers (RUTs).
 :
 : @return all company types.
 :) 
(: SVS FIX ME :)
declare function companies:types($companies-or-ruts as item*) as string*
{
  let $companies := companies:companies($companies-or-ruts)
  return $companies.Profiles.SVS.CompanyType 
};

(:~
 : <p>Retrieves all companies in the given sectors.</p>
 : 
 : @deprecated please use companies:companies-for-sectors#1
 : @param $sectors a sequence of sectors as strings.
 :
 : @return all companies in these sectors.
 :) 
(: SVS FIX ME :)
declare function companies:companies-for-sector($sectors as string*) as object*
{
  companies:companies-for-sectors($sectors)
};

(:~
 : <p>Retrieves all companies in the given sectors.</p>
 : 
 : @param $sectors a sequence of sectors as strings.
 :
 : @return all companies in these sectors.
 :)
(: SVS FIX ME :)
declare function companies:companies-for-sectors($sectors as string*) as object*
{
  let $conn := companies:connection()
  for $s in $sectors
  return mongo:find($conn, $entities:col, { "Profiles.SVS.Sector" : $s })
};

(:~
 : <p>Retrieves all companies whose type of business
 : matches the SIC (Standard Industrial Classification) code.</p>
 : 
 : @param $sic-codes a sequence of SIC codes.
 :
 : @return all companies with one of these SIC codes.
 :) 
(: SVS FIX ME :)
declare function companies:companies-for-SIC($sic-codes as string*) as object*
{
  let $conn := companies:connection()
  for $s in $sic-codes
  return mongo:find($conn, $entities:col, { "Profiles.SVS.SIC" : $s })
};

(:~
 : <p>Retrieves all companies whose company type matches the passed string(s).</p>
 : 
 : @deprecated please use companies:companies-for-types
 : @param $company-type a sequence of strings of "Corporation", "Partnership", or "unknown".
 :
 : @return all companies with matching company type.
 :) 
(: SVS FIX ME :)
declare function companies:companies-by-types($company-types as string*) as object*
{
  companies:companies-for-types($company-types)
};

(:~
 : <p>Retrieves all companies whose company type matches the passed string(s).</p>
 : 
 : @param $company-type a sequence of strings of "Corporation", "Partnership", or "unknown".
 :
 : @return all companies with matching company type.
 :) 
(: SVS FIX ME :)
declare function companies:companies-for-types($company-types as string*) as object*
{
  for $t in $company-types
  return 
    if ($t = ("Corporation", "Partnership", "unknown"))
    then (); 
    else error(QName("companies:UNKNOWN-COMPANY-TYPE"), $t || ": Unknown company type. Allowed values: \"Corporation\", \"Partnership\", or \"unknown\".");
    
  let $conn := companies:connection()
  for $t in $company-types
  return mongo:find($conn, $entities:col, { "Profiles.SVS.CompanyType" : $t })
};

(:~
 : <p>Return all companies with any of the given tags.</p>
 :
 : @param $tags the tags to filter.
 : @return all companies with the given tags.
 :) 
(: SVS FIX ME :)
declare function companies:companies-for-tags($tags as string*) as object*
{
  let $conn := companies:connection()
  for $tag in $tags
  return mongo:find($conn, $entities:col, { "Profiles.SVS.Tags" : $tag })
};

(:~
 : <p>Return all companies with any of the given ticker symbols.</p>
 :
 : <p>Tickers are case insensitive</p>
 :
 : @param $tickers the tickers to filter.
 : @return all companies with the given tickers.
 :)
declare function companies:companies-for-tickers(
  $tickers as  string*) as object*
{
  let $conn := companies:connection()
  for $ticker in $tickers
  return mongo:find($conn, $entities:col, { "Profiles.SVS.Tickers" : lower-case($ticker) })
};

(:~
 : <p>Return company type for a given company name. Company type can be one of:</p>
 : <p>
 :   <ul>
 :     <li>Corporation</li>
 :     <li>Partnership</li>
 :     <li>unknown</li>
 :   </ul>
 : </p>
 : 
 : @deprecated please use companies:types-for-names
 : @param $company-name the name of a company
 :
 : @return the company type string or "unknown" if the type can not be inferred
 :) 
(: SVS FIX ME :)
declare function companies:company-type($company-name as string) as string
{
  companies:types-for-names($company-name)
};


(:~
 : <p>Return company types for a given sequence of company names. Company type can be one of:</p>
 : <p>
 :   <ul>
 :     <li>Corporation</li>
 :     <li>Partnership</li>
 :     <li>unknown</li>
 :   </ul>
 : </p>
 : 
 : @param $company-names the sequence of the names of the companies
 :
 : @return the company type string or "unknown" if the type can not be inferred
 :) 
(: SVS FIX ME :)
declare function companies:types-for-names($company-names as string*) as string*
{
  for $company-name in $company-names
  let $lower-name as string := lower-case($company-name)
  return
    switch (true)
    case matches($lower-name, " corp")
    case matches($lower-name, " inc")
    case matches($lower-name, " co")
    case matches($lower-name, " bancorp")
    case matches($lower-name, " bancshares")
    case matches($lower-name, " group")
    case matches($lower-name, " llc")
    case matches($lower-name, " l\\.l\\.c\\.")
      return "Corporation"
    case matches($lower-name, " plc")
    case matches($lower-name, " lp")
    case matches($lower-name, " l\\.p\\.")
    case matches($lower-name, " lllp")
    case matches($lower-name, " ltd")
    case matches($lower-name, " partnership")
      return "Partnership"
    default return "unknown" 
};

(:~
 :
 : <p>Converts the input to a normalized RUT. The input
 : can be either a pure RUT without scheme, or an already
 : normalized RUT, or an entity object which contains a RUT
 : in its id field.</p>
 :
 : @param $rut_or_entity a RUT or an entity.
 :
 : @error svs:INVALID_PARAMETER if the RUT or entity is not valid
 :
 : @return the normalized RUT.
 :)
(: FIX ME, uncomment formttatting code when rut format is consistent :)
declare function companies:eid($companies-or-eids-or-ruts as item*) as string*
{
  let $preprocessed := for $c in $companies-or-eids-or-ruts
                       return switch(true)
                              case not $c instance of atomic return $c
                              case $c castable as string return string($c)
                              default return $c                              
  let $eids := entities:eid($preprocessed)
  for $eid in $eids
  return typeswitch ($eid)
         case $rut as string return
           switch(true)
           case starts-with($rut, $svs:RUT) return $rut
           (:case contains($rut, " ") return
               (: rut seems to contain a scheme, but not a RUT scheme, i.e. it's invalid :)
               error(QName("svs:INVALID_PARAMETER"), $rut || ": not a valid RUT"):)
           default return 
               (: FIX ME, uncomment me when rut format fixed in db 
               let $rut-clean := replace($rut, "[\\.\\-]", "")
               let $rut-length := if (string-length($rut-clean) gt 9) 
                   then error(QName("svs:INVALID_PARAMETER"), $rut || ": not a valid RUT") 
                   else string-length($rut-clean)
               let $control-code := substring($rut-clean, $rut-length)
               let $digits := substring($rut-clean, 1, string-length($rut-clean)-1)
               let $digits-integer := if ($digits castable as integer)
                       then $digits cast as integer
                       else error(QName("svs:INVALID_PARAMETER"), $rut || ": not a valid RUT")
               let $formatted-rut-digits := format-integer($digits-integer, "00000000") 
               return $svs:RUT || " " ||
                      substring($formatted-rut-digits, 1, 2) || "." ||
                      substring($formatted-rut-digits, 3, 3) || "." ||
                      substring($formatted-rut-digits, 6, 3) || "-" ||
                      $control-code
               :)
               $svs:RUT || " " || $rut
         default return error(
             QName("svs:INVALID_PARAMETER"),
             "Invalid entity or RUT (must be an object or a string): "
             || serialize($companies-or-eids-or-ruts))
};

(:~
 :)
declare %private function companies:connection() as anyURI
{
  let $credentials :=
      let $credentials := credentials:credentials("MongoDB", "xbrl")
      return if (empty($credentials))
             then error(QName("companies:CONNECTION-FAILED"), "no xbrl MongoDB configured")
             else $credentials
  return
    try {
      mongo:connect($credentials)
    } catch mongo:* {
      error(QName("companies:CONNECTION-FAILED"), $err:description)
    }
};
