jsoniq version "1.0";
(:
 : Copyright 2014 28msec Inc.
 :)


(:~
 : <p>This module provides functions for storing, retrieving, and modifying
 : reports. Reports can be used in BizQL queries. They can be
 : instantiated generating a business report.</p>
 :
 : <p>Reports are nothing else than a user-defined component. However,
 : one of their hypercubes (the default hypercube), as well as two of their
 : networks (presentation, concept-map) are special. A reports is identified
 : with an RID (Report schema ID).</p>
 :
 : <p>With this module, you can retrieve facts belonging to a report.
 : The concept map network will be used 
 : by default to map the report's concepts to reported concepts.</p>
 :
 : <p>Reports are stored in the collection reports in
 : the project's MongoDB database.</p>
 :
 : <p>A report needs to be a syntactically valid JSound document.</p>
 :
 : @author Charles Hoffman
 : @author Matthias Brantner
 : @author Dennis Knochenwefel
 : @author Ghislain Fourny
 :
 :)
module namespace reports = "http://xbrl.io/modules/bizql/reports";

import module namespace hypercubes = "http://xbrl.io/modules/bizql/hypercubes";
import module namespace hypercubes2 = "http://xbrl.io/modules/bizql/hypercubes2";
import module namespace networks = "http://xbrl.io/modules/bizql/networks";

declare namespace ver = "http://zorba.io/options/versioning";
declare option ver:module-version "1.0";

(:~
 : Name of the collection the report schemas are stored in.
 :)
declare variable $reports:col as string := "reports";

(:~
 : <p>Retrieves all reports.</p>
 : 
 : @return all reports.
 :) 
declare function reports:reports() as object*
{
  collection($reports:col)
};

(:~
 : <p>Return the reports with the given names (RIDs).</p>
 :
 : @param $reports-or-ids the ids of the reports (RIDs) or the
 : reports themselves.
 : 
 : @return the reports with the given RIDs or the 
 :   empty sequence if no report was found or the input
 : is an empty sequence.
 :) 
declare function reports:reports($reports-or-ids as item*) as object*
{
  let $ids as string* :=
    for $s in $reports-or-ids
    where $s instance of string
    return $s
  let $schemas as object* :=
    for $s in $reports-or-ids
    where $s instance of object
    return $s
  return
    (
      $schemas,
      if (exists($ids))
      then find($reports:col, 
                { "_id" : { "$in" : [ $ids ! reports:rid($$) ] } } )
      else ()
    )
};

(:~
 : <p>Adds the given report to the database.</p>
 :
 : @param $report the report schema to add.
 : 
 : @return the empty sequence.
 :
 : @error reports:INVALID-REPORT if the given report object does not
 :   contain a name field
 : @error reports:EXISTS if a report with the given name already exists
 :) 
declare %an:sequential function reports:add($report as object) as ()
{
  if (empty($report._id))
  then error(QName("reports:INVALID-REPORT"),
    "schema object does not contain an _id field");
  else if (exists(reports:reports($report._id)))
       then fn:error(QName("reports:EXISTS"),
                     $report._id || ": report schema already exists");
       else insert($reports:col, $report);
};


(:~
 : <p>Updates a report.</p>
 :
 : <p>Replaces a report in the database with the given report.
 : The report to be replaced is identified by the value of the _id
 : field of the given schema (RID).</p>
 : 
 : @param $report the new report
 : 
 : @return the empty sequence
 :
 : @error reports:DOES-NOT-EXIST if a report with the given name does not exist.
 :) 
declare %an:sequential function reports:update($report as object)
as ()
{
  let $existing := reports:reports($report._id)
  return if (empty($existing))
         then error(QName("reports:DOES-NOT-EXIST"),
             $report._id || ": report with given id does not exist");
         else edit($existing, $report);
};

(:~
 : <p>Deletes a report from the database.</p>
 : 
 : @param $report-or-id the report to delete or its RID.
 :
 : @return the empty sequence.
 :
 : @error report:DOES-NOT-EXIST if no report with the given RID exists.
 :) 
declare %an:sequential function reports:delete($report-or-id as item)
as ()
{
  let $report := reports:reports($report-or-id)
  let $id := reports:rid($report-or-id)
  return if (empty($report))
  then error(QName("reports:DOES-NOT-EXIST"),
    $id || ": report with given _id does not exist");
  else delete($report);
};

(:~
 :
 : <p>Converts the input to a normalized report identifier (RID). The input
 : can be either a pure RID, or a report object which contains an RID.</p>
 :
 : @param $report-or-id a report identifier (RID)) or a report object.
 :
 : @error reports:INVALID_PARAMETER if the RID or report is not valid
 :
 : @return the normalized RID.
 :)
declare function reports:rid($report-or-id as item) as atomic
{
  typeswitch ($report-or-id)
  case object return
    let $rid := $report-or-id._id
    return if(exists($rid))
           then $rid
           else error(QName("reports:INVALID_PARAMETER"), 
                      "Invalid report provided (no _id field)")
  case $rid as atomic return $rid
  default return error(
      QName("reports:INVALID_PARAMETER"),
      "Invalid report or RID (must be an object or an atomic): "
      || serialize($report-or-id))
};

(:~
 :
 : <p>Retrieves all facts from the supplied archives, that are relevant to the
 : supplied reports, and populates them with the default dimension values
 : when missing.</p>
 : <p>The default hypercube will be taken, and the concept maps and rules will
 : be used if any.</p>
 :
 : @param $report-or-id a report or its RID,
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function reports:facts(
    $report-or-id as item
)
as object*
{
  reports:facts($report-or-id, {})
};

(:~
 :
 : <p>Retrieves all facts from the supplied archives, that are relevant to the
 : supplied reports, and populates them with the default dimension values
 : when missing.</p>
 : 
 :
 : @param $report-or-id a report or its RID,
 : @param $options <a href="facts#standard_options">standard fact retrieving options</a> as well as
 : <ul>
 :   <li>FilterOverride: hypercube dimension specs (as defined as hypercubes:user-defined-hypercube)
 :   to override filters in the report's hypercube.</li>
 :   <li>HypercubeName: picks a different hypercube than the default one (xbrl:DefaultHypercube).</li>
 : </ul>
 :
 : @return a sequence of facts with populated dimension values.
 :)
declare function reports:facts(
    $report-or-id as item,
    $options as object?
)
as object*
{
  let $report := reports:reports($report-or-id)
  let $concept-map := networks:networks-for-components-and-short-names(
      $report,
      "ConceptMap")
  let $rules := $report.Rules
  let $hypercube :=
    if(exists($options.Hypercube))
    then $options.Hypercube
    else hypercubes:hypercubes-for-components(
             $report,
             if (exists($options.HypercubeName))
             then $options.HypercubeName
             else "xbrl:DefaultHypercube"
    )
  let $hypercube :=
    if(exists($options.FilterOverride))
    then hypercubes2:modify-hypercube(
      $hypercube,
      $options.FilterOverride
    )
    else $hypercube
  return hypercubes:facts(
      $hypercube,
      {|
        $options,
        { "ConceptMaps": $concept-map }[exists($concept-map)],
        { "Rules": $rules }[exists($rules)]
      |}
  )
};

