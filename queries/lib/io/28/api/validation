xquery version "3.0";
module namespace validate = "http://api.28.io/validation";

import module namespace resp = "http://www.28msec.com/modules/http/response";
import module namespace reflection = "http://www.zorba-xquery.com/modules/reflection";

declare function validate:type($type as xs:string) as xs:boolean
{
  fn:matches($type,"^\{http://[a-zA-Z0-9\./]+\}[a-zA-Z]+$")
};

declare function validate:expression($expression as xs:string, $is-domain-expr as xs:boolean) as xs:boolean
{
  if (fn:contains($expression, ";")) then false() else
  try
  {
    (true(),reflection:eval("(<a/>)" || (if ($is-domain-expr) then "" else "/") || $expression))[1]    
  }
  catch *
  {
    false()
  }
};

declare function validate:by-schema($obj as object(), $schema as object())
{
  validate:by-schema-obj($obj, $schema, "")
};

declare function validate:by-schema-primitive($obj, $schema-type as xs:string, $path)
{
  let $type := fn:replace($schema-type,"\?","")
  let $is-optional := fn:ends-with($schema-type, "?")
  return
    if (not($is-optional) and empty($obj))
    then fn:error($resp:bad-request, "Missing required value: " || $path)
    else if (empty($obj))
    then ()
    else if ($type eq "xs:anyURI")
    then if ($obj castable as xs:anyURI) then () else fn:error($resp:bad-request, "anyURI required: " || $path)
    else if ($type eq "xs:integer")
    then if ($obj castable as xs:integer) then () else fn:error($resp:bad-request, "integer required: " || $path)

    else if ($type eq "type")
    then if (validate:type($obj)) then () else fn:error($resp:bad-request, "Type required: " || $path)
    else if ($type eq "key-expr")
    then if (validate:expression($obj, false())) then () else fn:error($resp:bad-request, "Expression required: " || $path)
    else if ($type eq "domain-expr")
    then if (validate:expression($obj, true())) then () else fn:error($resp:bad-request, "Expression required: " || $path)
    else ()
};

declare function validate:by-schema-obj($obj as object(), $schema as object(), $path as xs:string)
{
  for $key in jn:keys($schema)
  return
    if ($schema($key) instance of array())
    then validate:by-schema-array($obj($key), $schema($key), $path || $key || ".")      
    else validate:by-schema-primitive($obj($key), $schema($key), $path || $key)
    ,
  for $key in jn:keys($obj)
  where not($key=jn:keys($schema))
  return fn:error($resp:bad-request, "Additional field: " || $path || $key)
};

declare function validate:by-schema-array($obj, $schema as array(), $path as xs:string)
{
  if ($schema(1) eq "required" and (empty($obj) or not($obj instance of array())))
  then fn:error($resp:bad-request, "Missing required array: " || $path )
  else if ($schema(1) eq "optional" and exists($obj) and not($obj instance of array()))
  then fn:error($resp:bad-request, "Array expected: " || $path )
  else (),

  if ($obj instance of array())
  then
    let $obj-schema := $schema(2)
    return
      if ($obj-schema instance of object())
      then
        for $entry at $idx in jn:members($obj)
        return validate:by-schema-obj($entry, $obj-schema, $path || "[" || xs:string($idx) || "]." )
      else
        for $entry at $idx in jn:members($obj)
        return validate:by-schema-primitive($entry, $obj-schema, $path || "[" || xs:string($idx) || "]" ) 
  else ()
};
