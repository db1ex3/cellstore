xquery version "3.0";
module namespace api = "http://api.28.io/databrowser"; 

import module namespace functx = "http://www.functx.com";

import module namespace dml = "http://www.zorba-xquery.com/modules/store/static/collections/dml";

import module namespace http-client="http://www.zorba-xquery.com/modules/http-client";
import module namespace base64 = "http://zorba.io/modules/base64";
import module namespace http = "http://expath.org/ns/http-client";
import module namespace xmlmod = "http://zorba.io/modules/xml";
import module namespace req = "http://www.28msec.com/modules/http/request";
import module namespace res = "http://www.28msec.com/modules/http/response";
import module namespace project = "http://www.28msec.com/modules/project";

import module namespace r = "http://www.zorba-xquery.com/modules/reflection";
import module namespace ref = "http://zorba.io/modules/reference";

import module namespace zerr = "http://zorba.io/errors";

import schema namespace opt = "http://zorba.io/modules/xml-options";

declare namespace ext = "http://www.zorba-xquery.com/extensions";

(:~
 : Data Browser API dispatched.
 : Handles API authorization to the portal and dispatching.
 :)
declare %an:sequential function api:dispatch()
{
  res:set-header("Access-Control-Allow-Origin",  "*");
  res:set-header("Access-Control-Allow-Headers", "X-Requested-With, Content-Type");
  res:set-header("Access-Control-Expose-Headers", "X-28msec-Error");
  
  variable $segments := tokenize(req:path(), "/");
  variable $resource := $segments[4];

  if(req:method-options()) then
    api:options()
  else if($resource eq "delete") then
      api:delete()
  else if($resource eq "edit") then
      api:edit()
  else if($resource eq "run") then
      api:run(false())
  else if($resource eq "apply") then
      api:run(true())
  else if($resource = "upload") then
    api:upload()
  else if($resource eq "collection" and req:method-get() and count($segments) gt 4) then
    api:collection($segments[5])
  else error($res:bad-request)
};

declare %an:sequential function api:options()
{
  res:set-status-code(200);
  variable $request-method := req:header-value("Access-Control-Request-Method");
  if($request-method) then 
    res:set-header("Access-Control-Allow-Methods", $request-method);
  else ();
};

declare %an:sequential function api:collection($name as xs:string) {
  res:set-content-type("application/json");
  variable $page-size := try { req:parameter-values("pageSize", "10") ! xs:unsignedInt(.) } catch err:FORG0001 { error($res:bad-request) };
  variable $from      := try { req:parameter-values("from", "1") ! xs:unsignedInt(.) } catch err:FORG0001 { error($res:bad-request) };
  variable $count     := count(db:collection($name));
  variable $result    := subsequence(db:collection($name, $from - 1), 1, $page-size);
  variable $items     := api:serialize($result)("items");
  {
    "total": $count,
    "from": $from,
    "pageSize": $page-size,
    "items": $items
  }
};

declare %an:sequential function api:delete()
{
  variable $id  := req:parameter-values("id", error($res:bad-request, "Missing ID parameter."));
  variable $doc := try { ref:dereference($id) } catch * { error($res:bad-request, "Invalid document ID.") };
  db:delete($doc);
  res:set-status-code(200);
};

declare %an:sequential function api:edit()
{
  variable $id  := req:parameter-values("id", error($res:bad-request, "Missing ID parameter."));
  variable $content := try { req:text-content() } catch * { error($res:bad-request, "Document parameter.")  };
  variable $old-doc := try { ref:dereference($id) } catch * { error($res:bad-request, "Invalid document ID.") };
  variable $content-type := req:content-type();
  variable $doc := if(contains($content-type, "json")) then jn:parse-json($content) else if(contains($content-type, "xml")) then parse-xml($content) else $content;
  db:edit($old-doc, $doc);
  res:set-status-code(200);
};

(:~
 :
 :)
declare %an:sequential function api:run($sequential as xs:boolean)
as object() 
{
  res:set-content-type("application/json");
  let $query := req:parameter-values("query", error($res:bad-request))
  let $has-version := starts-with($query, "jsoniq ") or  starts-with($query, "xquery ")
  (:
  let $from  := req:parameter-values("from", 1) ! number(.)
  let $to    := req:parameter-values("to", $from + $api:page-padding) ! number(.)
  :)
  return
    try {
      let $query := if (not($has-version))
                    then concat('jsoniq version "1.0";
', $query)
                    else $query
      let $result := if($sequential) then r:eval-s($query) else r:eval($query)
      return
        api:serialize($result)
    } catch * {
      {
        res:set-status-code(500);
        res:set-header("X-28msec-Error", "true");
        {
          "error": true(),
          "code": $err:code,
          "description": $err:description,
          "module": $err:module,
          "line-number": if (empty($err:line-number)) 
                         then 1
                         else if (not($has-version)) 
                              then $err:line-number - 1 
                              else $err:line-number,
          "column-number": if (empty($err:column-number)) 
                           then 1 
                           else $err:column-number,
          "line-number-end": if (empty($zerr:line-number-end)) 
                             then 1
                             else if (not($has-version)) 
                                  then $zerr:line-number-end - 1 
                                  else $err:line-number,
          "column-number-end": if (empty($zerr:column-number-end)) 
                               then 1 
                               else $zerr:column-number-end
        }
      }
  }
};

declare function api:serialize($items as item()*) as object() {
    let $items := for $item in $items
                  let $ser := serialize($item, res:serializer-defaults-json-xml-hybrid())
                  let $collname := try { db:collection-name($item) } catch * { "" }
                  let $id := if($collname eq "") then "" else try { ref:reference($item) } catch * { "" }
                  let $item := {
                    "item": $ser,
                    "id": $id,
                    "json": $item instance of json-item() or $item instance of xs:anyAtomicType
                  }
                  return $item
    return {
      "items": [ $items ]
    }
};

(:
declare function api:serialize($items as item()*, $from as xs:double, $to as xs:double) as object() {
    let $result := api:serialize(subsequence($items, $from), (), 0, $to - $from)
    let $hasMore := $result[1]
    let $items := [ subsequence($result, 2) ]
    return {
      "items": $items,
      "hasMore": $hasMore,
      "from": if($hasMore) then $to else 0
    }
};

declare function api:serialize($items as item()*, $result as object()*, $size as xs:integer, $limit as xs:double) as item()* {
  if(empty($items) or $size gt $limit) then
    (exists($items), $result)
  else
    let $item := $items[1]
    let $ser := serialize($item, res:serializer-defaults-json-xml-hybrid())
    let $collname := try { db:collection-name($item) } catch * { "" }
    let $id := if($collname eq "") then "" else try { ref:reference($item) } catch * { "" }
    let $item := {
      "item": $ser,
      "id": $id,
      "json": $item instance of json-item() or $item instance of xs:anyAtomicType
    } 
    return api:serialize(subsequence($items, 2), ($result, $item), $size + 1, $limit)
};
:)

declare %private function api:error-json($code,
                                         $description,
                                         $module,
                                         $line-number,
                                         $column-number)
{
  {
    "code": $code,
    "description": $description,
    "module": $module,
    "line-number": $line-number,
    "column-number": $column-number
  }
};

declare %an:sequential function api:upload()
{
  res:set-content-type("application/json");
  res:set-header("Access-Control-Allow-Origin","*");

  try {

    variable $url        := req:parameter-values("url");
    variable $collection := req:parameter-values("collection");
    variable $mimetype := req:parameter-values("mimetype");

    variable $choplevels := req:parameter-values("choplevels","0");
    variable $flatten := req:parameter-values("flatten","false") = "true";
    variable $nodetype := req:parameter-values("nodetype","document");

    if (fn:empty($url)) then
    {
      fn:error($res:bad-request, "Mandatory parameter url missing");
    }
    else if (fn:empty($collection)) then
    {
      fn:error($res:bad-request, "Mandatory parameter collection missing");
    }
    else if (fn:empty($mimetype)) then
    {
      fn:error($res:bad-request, "Mandatory parameter mimetype missing");
    }
    else
      if (fn:contains($mimetype, "xml"))
      then
        if (not($nodetype = (("document","element")))) 
        then fn:error($res:bad-request, "Unsupported node type");
        else if (not($choplevels castable as xs:integer))
        then fn:error($res:bad-request, "Choplevels must be an integer.");
        else ();
      else ();
    {}

    variable $ns    := functx:substring-before-last($collection, ":");
    variable $name  := functx:substring-after-last($collection, ":");
    variable $qname := fn:QName($ns, $name);

    (: getting the file content :)
    variable $filepicker := http-client:get-text($url);

    if ($filepicker[1]/@status ne 200) then
      fn:error(xs:QName("api:FILEPICKER_FAILED"), "Accessing filepicker data failed: " || data($filepicker[1]/@message));
    else
      ();

    (: deleting the file content :)
    variable $delete-res := http-client:delete($url);
    if ($delete-res[1]/@status ne 200) then

      (: @TODO: the reporting module is not available in the databrowser. 
                this needs to be fixed at some point 
      reporting:send-error-report(
        project:name(),
        (), 
        "Removing filepicker data failed", 
        "Filepicker message: " || data($delete-res[1]/@message)); :)
      ();
    else
      ();


    variable $content := $filepicker[2];

    if (fn:contains($mimetype, "xhtml") or fn:contains($mimetype, "xml")) 
    then
    
      if ($nodetype eq "element")
      then
        for $node in xmlmod:parse($content,
          <opt:options>
            <opt:parse-external-parsed-entity opt:skip-root-nodes="{ xs:integer($choplevels) }" opt:skip-top-level-text-nodes="true"/>            
          </opt:options>)
        where $node/self::element()
        return 
          try 
          {
            dml:insert-nodes($qname, $node );
          } catch zerr:ZDTY0001 {
            dml:insert-nodes($qname, validate lax { $node } );
          }
      else if (xs:integer($choplevels) > 0)
      then
        for $node in xmlmod:parse($content,
          <opt:options>
            <opt:parse-external-parsed-entity opt:skip-root-nodes="{ xs:integer($choplevels)-1 }" opt:skip-top-level-text-nodes="true"/>            
          </opt:options>)
        where $node/self::element()
        return (# ext:no-copy #) { dml:insert-nodes($qname, document { $node/node() } ) };
      else      
        (# ext:no-copy #) { dml:insert-nodes($qname, fn:parse-xml($content)) };
    else if (fn:contains($mimetype, "json")) then
      if ($flatten)
      then
        for $e in jn:parse-json($content, { "jsoniq-strip-top-level-array" : true(), "jsoniq-multiple-top-level-items" : true() })
        return (# ext:no-copy #) { dml:insert($qname, $e) };
      else (# ext:no-copy #) { dml:insert($qname, jn:parse-json($content)) };
    else 
      fn:error(
        xs:QName("api:FILEPICKER_FAILED"),
        "Filepicker provides data with an unknown media type: " || $mimetype);
  } catch * {
     if(res:valid-status($err:code))
     then
       res:set-status($err:code);
     else
       (: http:internal-server-error if not a valid http status :)
       res:set-status($res:internal-server-error);
    exit returning
      api:error-json($err:code, $err:description, $err:module,
                     $err:line-number, $err:column-number);
  }

  {}
};
